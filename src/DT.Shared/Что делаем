Так. 
1. Создаем в каждом сервисе с бизнес логикой Consumers директорию с 3-мя поддиректориями под каждый паттерн.
2. Для каждого паттерна реализуется свой Consumer
3. Consumer наследуется от IConsumer, исходник которого располагается в Shared проекте
4. IConsumer предоставляет только один метод - Consume(ConsumeContext<TMessage>)
5. ConsumeContext<TMessage> - класс, который хранит в себе экземпляр сообщения и вспомогательные данные для работы с передачей сообщения
в микросервисной архитектуре 
6. (тех. долг) Из каждого сервиса убраны копипасты логики работы с брокером.
7. Вся логика с Publish / Subscribe была вынесена в отдельный Shared проект только как интерфейсы.
8. Добавлен класс RabbitMqBrokerBase в Shared, цель которого реализовать в себе базовые виртуальные методы Publish и Subscribe.
9. Но каждый сервис сам реализовывает собственное представление того, как этот брокер будет сконфигурирован, на кого подписан 
через метод расширения в классе RabbitMqExtensions, который кастомный для каждого сервиса.
10. Consumers в сервисах не владеют ссылкой на брокера, чтобы Publish-ить сообщения. 
11. Вместо этого за это отвечает ConsumeContext<TMessage>, который имеет этот функционал
12. Каждый сервис-проект имеет скрипт "{Service.Name}Service" для обработки бизнес логики.
13. Методы этих классов используют Consumer классы.